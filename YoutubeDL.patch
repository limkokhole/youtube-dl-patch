--- /home/xiaobai/Downloads/youtube-dl/2/youtube-dl/youtube_dl/YoutubeDL.py	2020-08-02 12:27:34.798209234 +0800
+++ /home/xiaobai/.local/lib/python3.6/site-packages/youtube_dl-2020.7.28-py3.6.egg/youtube_dl/YoutubeDL.py	2020-08-02 13:28:06.562117058 +0800
@@ -112,6 +112,16 @@
 if compat_os_name == 'nt':
     import ctypes
 
+# hole style
+import platform
+from pathlib import PurePath, Path
+plat = platform.system().lower()
+if ('window' in plat) or plat.startswith('win'):
+    IS_WIN = True
+else:
+    IS_WIN = False
+WIN_MAX_PATH = 255
+
 
 class YoutubeDL(object):
     """YoutubeDL class.
@@ -631,6 +641,83 @@
         except UnicodeEncodeError:
             self.to_screen('[download] The file has already been downloaded')
 
+    def get_max_path(self, arg_cut, fs_f_max, fpart_excluded_immutable, immutable):
+        #print('before f: ' + fpart_excluded_immutable)
+        if arg_cut >= 0:
+            fpart_excluded_immutable = fpart_excluded_immutable[:arg_cut]
+        if immutable:
+            # immutable shouldn't limit to 1 byte(may be change next time or next project), so need encode also
+            immutable_len = len(immutable.encode('utf-8'))
+        else:
+            immutable_len = 0
+
+        space_remains = fs_f_max - immutable_len
+        if space_remains < 1:
+            return '' # No more spaces to trim(bcoz directories name too long), so only shows PinID.jpg
+
+        # range([start], stop[, step])
+        # -1 step * 4 loop = -4, means looping 4 bytes(UTF-8 max) from right to left
+        for gostan in range(space_remains, space_remains - 4, -1):
+            try:
+                fpart_excluded_immutable = fpart_excluded_immutable.encode('utf-8')[: gostan ].decode('utf-8')
+                break # No break still same result, but waste
+            except UnicodeDecodeError:
+                pass #print('Calm down, this is normal: ' + str(gostan) + ' f: ' + fpart_excluded_immutable)
+        #print('after f: ' + fpart_excluded_immutable)
+        # Last safety resort, in case any bug:
+        fpart_excluded_immutable_base = self.sanitize ( fpart_excluded_immutable ) 
+        if fpart_excluded_immutable_base != fpart_excluded_immutable.strip(): # Original need strip bcoz it might cut in space
+            print('\n[! A] Please report to me which Link/scenario it print this log.\
+                Thanks:\n{} # {} # {} # {} # {} \n\n' \
+                .format(arg_cut, fs_f_max, repr(fpart_excluded_immutable), repr(fpart_excluded_immutable_base), immutable), end='' )  
+        return fpart_excluded_immutable_base
+
+    def sanitize(self, path):
+        # trim multiple whitespaces # ".." is the responsibilities of get max path
+
+        #If using .replace('  ', ' ') will only replace once round, e.g. '    ' become 
+        path = ' '.join(path.split()) 
+
+        if IS_WIN:
+            # Use PurePath instead of os.path.basename  https://stackoverflow.com/a/31273488/1074998 , e.g.:
+            #>>> PurePath( '/home/iced/..'.replace('..', '') ).parts[-1] # get 'iced'
+            #>>> os.path.basename('/home/iced/..'.replace('..', '')) # get empty ''
+            # Ensure .replace('..', '') is last replacement before .strip() AND not replace back to dot '.'
+            # https://docs.microsoft.com/en-us/windows/win32/fileio/naming-a-file
+            p = PurePath( path.replace('<', '').replace('>', '').replace('"', '\'').replace('?', '').replace('*', '').replace('/', '_').replace('\\', '_').replace('|', '_').replace(':', '_').replace('.', '_').strip() )
+            if p.parts:
+                return p.parts[-1]
+            else:
+                return ''
+        else:
+            p = PurePath( path.replace('/', '|').replace(':', '_').replace('.', '_').strip() )
+            if p.parts:
+                return p.parts[-1]
+            else:
+                return ''
+
+    def get_fs_max(self):
+        fs_f_max = None
+        if IS_WIN: # Sorry but I don't bother to fix WIN_MAX_PATH which nid prefix \\?\\ in full path
+            fs_f_max = WIN_MAX_PATH
+        else:
+            # 255 bytes is normaly fs max, 242 is docker max, 143 bytes is eCryptfs max
+            # If IS_WIN check here then need add \\?\\ for WIN-only
+            for fs_f_max_i in (255, 242, 143):
+                try:
+                    with open('A'*fs_f_max_i, 'r') as f:
+                        fs_f_max = fs_f_max_i # if got really this long A exists will come here
+                        break
+                except FileNotFoundError:
+                    fs_f_max = fs_f_max_i # Normally came here in first loop
+                    break
+                except OSError: # e.g. File name too long
+                    pass
+            if fs_f_max is None:
+                fs_f_max = os.statvfs('.').f_namemax
+        return fs_f_max
+
+
     def prepare_filename(self, info_dict):
         """Generate the output filename."""
         try:
@@ -660,6 +747,50 @@
 
             outtmpl = self.params.get('outtmpl', DEFAULT_OUTTMPL)
 
+            #'''
+            print('hole style')
+            path = Path(outtmpl)
+            save_dir = str(path.parent)
+            print('save into: ' + repr(save_dir))
+            arg_cut = -1
+            fs_f_max = self.get_fs_max()
+            print('fs_f_max: ' + str(fs_f_max))
+            ext = self.sanitize(template_dict['ext'])
+            dat = self.sanitize(template_dict['upload_date'])
+            #print('template_dict: ' + repr(template_dict))
+            if not ext.strip():
+                ext = 'unknown'
+            if not dat.strip():
+                dat = 'NA'
+            template_dict['id'] = self.sanitize( str(template_dict['id']) )
+            immutable = self.sanitize( '-' + dat + '-' + template_dict['id'] + '.' +  ext + '.part')
+            #print(template_dict['title'])
+            fpart_excluded_ext_before  = self.sanitize( template_dict['title'] )
+            fpart_excluded_ext = self.get_max_path(arg_cut, fs_f_max, fpart_excluded_ext_before, immutable)
+            if fpart_excluded_ext:
+                if fpart_excluded_ext_before == fpart_excluded_ext: # means not truncat
+                    # Prevent confuse when trailing period become '..'ext and looks like '...'
+                    if fpart_excluded_ext[-1] == '.':
+                        fpart_excluded_ext = fpart_excluded_ext[:-1]
+                else: # Truncated
+                    # No need care if two/three/... dots, overkill to trim more and loss information
+                    if fpart_excluded_ext[-1] == '.':
+                        fpart_excluded_ext = fpart_excluded_ext[:-1]
+                    fpart_excluded_ext = self.get_max_path(arg_cut, fs_f_max, fpart_excluded_ext
+                        , '...' + immutable)
+
+                    fpart_excluded_ext = fpart_excluded_ext + '...'
+
+            print(repr(template_dict['id']))
+            print(repr(fpart_excluded_ext + '.' +  ext))
+            filename = os.path.abspath( os.path.join(save_dir, '{}'.format( fpart_excluded_ext + \
+                                        '-' + dat + '-' + template_dict['id'] + '.' +  ext)) )
+            print('hole fname: ' + repr(filename))
+            return sanitize_path(filename)
+            #'''
+
+
+
             # For fields playlist_index and autonumber convert all occurrences
             # of %(field)s to %(field)0Nd for backward compatibility
             field_size_compat_map = {
@@ -709,7 +840,10 @@
             # be expanded. For example, for outtmpl "%(title)s.%(ext)s" and
             # title "Hello $PATH", we don't want `$PATH` to be expanded.
             filename = expand_path(outtmpl).replace(sep, '') % template_dict
-
+            #print('sep: ' + repr(sep))
+            #print('outmpl: ' + repr(outtmpl))
+            #print('template_dict: ' + repr(template_dict))
+            #print('filename: ' + repr(filename))
             # Temporary fix for #4787
             # 'Treat' all problem characters by passing filename through preferredencoding
             # to workaround encoding issues with subprocess on python2 @ Windows
@@ -860,6 +994,10 @@
 
         if result_type == 'video':
             self.add_extra_info(ie_result, extra_info)
+            #print('ie: ' + repr(ie_result))
+            #print('iet: ' + repr(type(ie_result)))
+            #print('dw: ' + repr(download))
+            #print('dwt: ' + repr(type(download)))
             return self.process_video_result(ie_result, download=download)
         elif result_type == 'url':
             # We have to add extra_info to the results because it may be
@@ -1133,7 +1271,6 @@
         SINGLE = 'SINGLE'
         GROUP = 'GROUP'
         FormatSelector = collections.namedtuple('FormatSelector', ['type', 'selector', 'filters'])
-
         def _parse_filter(tokens):
             filter_parts = []
             for type, string, start, _, _ in tokens:
