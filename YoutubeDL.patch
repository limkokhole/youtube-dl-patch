--- YoutubeDL.py.orig	2020-08-03 01:59:36.281413712 +0800
+++ YoutubeDL.py	2020-08-03 18:29:44.238281546 +0800
@@ -42,6 +42,10 @@
     compat_urllib_request,
     compat_urllib_request_DataHandler,
 )
+
+# hole patch:
+from .utils import get_fs_max, get_max_path, sanitize_patch
+
 from .utils import (
     age_restricted,
     args_to_str,
@@ -112,6 +116,8 @@
 if compat_os_name == 'nt':
     import ctypes
 
+# hole patch
+from pathlib import PurePath, Path
 
 class YoutubeDL(object):
     """YoutubeDL class.
@@ -631,7 +637,8 @@
         except UnicodeEncodeError:
             self.to_screen('[download] The file has already been downloaded')
 
-    def prepare_filename(self, info_dict):
+
+    def prepare_filename(self, info_dict, format_name=''):
         """Generate the output filename."""
         try:
             template_dict = dict(info_dict)
@@ -660,6 +667,60 @@
 
             outtmpl = self.params.get('outtmpl', DEFAULT_OUTTMPL)
 
+            #''' 
+            # Note: Only do for python 3 and Linux-like systems
+            #print('hole style')
+            path = Path(outtmpl)
+            save_dir = str(path.parent)
+            print('save into: ' + repr(save_dir))
+            arg_cut = -1
+            fs_f_max = get_fs_max()
+            #print('fs_f_max: ' + str(fs_f_max))
+            # must hard code some max such as 30 for .ext which is last resort if all empty
+            # No need worry if [:30] means 30*4 bytes unicode, because slice is per unicode glyph
+            format_name = format_name.strip()
+            if format_name:
+                format_name = sanitize_patch(format_name).strip()[:30].strip()
+            ext = sanitize_patch(template_dict['ext']).strip()[:30].strip()
+            if format_name:
+                ext = format_name + '.' + ext
+                #print('format name final: ' + repr(ext))
+            dat = sanitize_patch(template_dict['upload_date']).strip()
+            #print('template_dict: ' + repr(template_dict))
+            if not ext:
+                ext = 'unknown'
+            if not dat:
+                dat = 'NA'
+            template_dict['id'] = sanitize_patch( str(template_dict['id']) )
+            immutable = sanitize_patch( '-' + dat + '-' + template_dict['id'] + '.' +  ext + '.part')
+            #print('title: ' + template_dict['title'])
+            fpart_excluded_ext_before  = sanitize_patch( template_dict['title'] )
+            fpart_excluded_ext = get_max_path(arg_cut, fs_f_max, fpart_excluded_ext_before, immutable, True)
+            if fpart_excluded_ext:
+                if fpart_excluded_ext_before == fpart_excluded_ext: # means not truncat
+                    # Prevent confuse when trailing period become '..'ext and looks like '...'
+                    if fpart_excluded_ext[-1] == '.':
+                        fpart_excluded_ext = fpart_excluded_ext[:-1]
+                else: # Truncated
+                    # No need care if two/three/... dots, overkill to trim more and loss information
+                    if fpart_excluded_ext[-1] == '.':
+                        fpart_excluded_ext = fpart_excluded_ext[:-1]
+                    fpart_excluded_ext = get_max_path(arg_cut, fs_f_max, fpart_excluded_ext
+                        , '...' + immutable, True)
+
+                    fpart_excluded_ext = fpart_excluded_ext + '...'
+
+            #print('vid: '+ repr(template_dict['id']))
+            #print('fpart: ' + repr(fpart_excluded_ext + '.' +  ext))
+            # In case date + video id very long, just remains .ext as last resort:
+            fpart = get_max_path(arg_cut, fs_f_max, fpart_excluded_ext +  '-' + dat + '-' + template_dict['id'], '.' + ext, False) + '.' + ext
+            filename = os.path.abspath( os.path.join(save_dir, '{}'.format( fpart )) )
+            print('hole fname: ' + repr(filename))
+            return sanitize_path(filename)
+            #'''
+
+
+
             # For fields playlist_index and autonumber convert all occurrences
             # of %(field)s to %(field)0Nd for backward compatibility
             field_size_compat_map = {
@@ -709,7 +770,10 @@
             # be expanded. For example, for outtmpl "%(title)s.%(ext)s" and
             # title "Hello $PATH", we don't want `$PATH` to be expanded.
             filename = expand_path(outtmpl).replace(sep, '') % template_dict
-
+            #print('sep: ' + repr(sep))
+            #print('outmpl: ' + repr(outtmpl))
+            #print('template_dict: ' + repr(template_dict))
+            #print('filename: ' + repr(filename))
             # Temporary fix for #4787
             # 'Treat' all problem characters by passing filename through preferredencoding
             # to workaround encoding issues with subprocess on python2 @ Windows
@@ -860,6 +924,10 @@
 
         if result_type == 'video':
             self.add_extra_info(ie_result, extra_info)
+            #print('ie: ' + repr(ie_result))
+            #print('iet: ' + repr(type(ie_result)))
+            #print('dw: ' + repr(download))
+            #print('dwt: ' + repr(type(download)))
             return self.process_video_result(ie_result, download=download)
         elif result_type == 'url':
             # We have to add extra_info to the results because it may be
@@ -1133,7 +1201,6 @@
         SINGLE = 'SINGLE'
         GROUP = 'GROUP'
         FormatSelector = collections.namedtuple('FormatSelector', ['type', 'selector', 'filters'])
-
         def _parse_filter(tokens):
             filter_parts = []
             for type, string, start, _, _ in tokens:
@@ -1911,9 +1978,10 @@
                         for f in requested_formats:
                             new_info = dict(info_dict)
                             new_info.update(f)
-                            fname = prepend_extension(
-                                self.prepare_filename(new_info),
-                                'f%s' % f['format_id'], new_info['ext'])
+                            #fname = prepend_extension(
+                            fname = self.prepare_filename(new_info, 'f%s' % f['format_id'])
+                            #'f%s' % f['format_id'], new_info['ext'])
+                            #print('fname: ' + repr(fname))
                             if not ensure_dir_exists(fname):
                                 return
                             downloaded.append(fname)
